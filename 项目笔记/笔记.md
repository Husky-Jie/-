# 1、mvc消息转换器

```java
package com.husky.common;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}

```



## 1.1扩展mvc框架的消息转换器

```java
/*
     * 返回的R对象默认使用了消息转换器*/

    // 扩展mvc框架的消息转换器
    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 创建消息转换器对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        // 设置自定义的对象转换器，底层使用Jackson将将Java对象转为json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        // 将上面的消息转换器对象追加到mvc框架的转换器集合中
        converters.add(0,messageConverter);
    }
```



# 2.通过线程设置获取用户的id

```java
package com.husky.common;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2022/10/12
 * Time: 10:34
 */

/*
* 基于ThreadLocal封装工具类，保存用户和获取用户当前的id*/
public class BaseContext {
    // 每个线程单独保存一个副本
    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    // 设置用户id
    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    // 获取用户id
    public static Long getCurrentId() {
        return threadLocal.get();
    }
}
```

```java
package com.husky.common;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2022/10/11
 * Time: 17:52
 */

/*
* 自定义元数据对象处理器
* 处理公共字段
* */
@Component
@Slf4j
public class MyObjectHandler implements MetaObjectHandler {

    // 公共字段填充insert
    /*
    * 重写方法中不能使用HttpSession获取用户id
    * 使用ThreadLocal封装工具类，保存用户和获取用户当前的id
    * 首先在过滤器的登录判断中用ThreadLocal封装工具类中设置用户id
    * 最后在公共字段处理器的重写方法中获取用户id*/
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段填充insert");
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("createUser", BaseContext.getCurrentId());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }

    // 公共字段填充update
    @Override
    public void updateFill(MetaObject metaObject) {
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
}

```

# 3.文件上传下载

## 3.1文件上传

Spring框架对文件上传进行了封装，只需在controller的方法中声明MultipartFile类型的参数即可接收上传的文件

![image-20221013151545791](.\image-20221013151545791.png)

```java
package com.husky.controller;

import com.husky.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2022/10/13
 * Time: 10:38
 */
@Slf4j
@RestController
@RequestMapping("/common")
public class CommonController {

    @Value("${reggie.path}")
    private String basePath;
    /*
    * 参数名字要与前端的上传组件的name属性的值要一致
    * file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除
    */
    @PostMapping("/upload")
    public R<String> upload(MultipartFile file) {
        // 原始文件名
        String originalFilename = file.getOriginalFilename();
        // 截取原始文件名的后缀
        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));

        // 使用uuid随机定义文件名，防止文件名重复造成文件覆盖
        String fileName = basePath + UUID.randomUUID().toString() + suffix;

        // 判断路径是否存在，不存在则创建
        File file1 = new File(basePath);
        if (!file1.exists()){
            file1.mkdirs();
        }

        // 将临时文件转存到指定位置
        try {
            file.transferTo(new File(fileName));
        } catch (IOException e) {
            e.printStackTrace();
        }

        return R.success(fileName);
    }
}

```

# 4.Git管理

将项目创建为git管理

<img src=".\笔记.assets\image-20230108112212895.png" alt="image-20230108112212895" style="zoom:50%;" />

将项目添加到git仓库，右键+Add，并且推送push

创建分支，push

回到主分支，合并分支

![image-20221101104343841](.\img\image-20221101104343841.png)

# 5.spring Cache

Spring Cache 是一个框架，实现了基于注解的缓存功能，只需简单地加入一个注解，就能实现缓存功能

## 5.1 常用注解

![image-20221101104851153](.\img\image-20221101104851153.png)



# 6.读写分离

## 6.1MySQL主从复制

MySQL主从复制是一个异步的复制过程，底层是基于MySQL数据库自带的二进制日志功能。就是一台或多台

MySQL数据库（salve，即从库）从另一台MySQL数据库（master，即主库）进行日志的复制然后在解析日志

并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MySQL自带的功能，不需要第三方工具。

![image-20221101154532727](.\img\image-20221101154532727.png)



## 6.2sharding-jdbc

![image-20221102210149061](.\img\image-20221102210149061.png)



# 7.liunx中的操作

set nu：显示行数

## 7.1mysql

1. service mysql start;     启动MySQL服务

2. show master/slave status\G    	查看主库/从库的状态

3. change master to master_host='192.168.108.128',master_user='root',master_password='1234',master_log_file='mysql-bin.000006',master_log_pos=1848;

   在从库中选择master为主库

4. CREATE USER 'user'@ 'X.X.X.X' IDENTIFIED BY 'password';
   GRANT REPLICATION SLAVE ON *.* TO 'user'@'X.X.X.X' ;

   新建用户

5. stop/start slave；停止/打开 从库线程

# 8.前后端分离开发

![image-20221106110227280](.\img\image-20221106110227280.png)

## 8.1开发流程

![image-20221106110402842](.\img\image-20221106110402842.png)



# 8.2Yapi

![image-20221106111206203](.\img\image-20221106111206203.png)

## 8.3Swagger

![image-20221106112544911](.\img\image-20221106112544911.png) 

### 8.3.1常用注解

![image-20221106155217561](.\img\image-20221106155217561.png)



### 8.3.2 Swagger配置类

```java
@EnableSwagger2
@Configuration
public class Swagger2Config {
    @Bean
    public Docket createRestApi() {
        String groupName="3.X版本";
        Docket docket=new Docket(DocumentationType.OAS_30)
                .apiInfo(apiInfo())
                //分组名称
                .groupName(groupName)
                .select()
                //这里指定Controller扫描包路径
                .apis(RequestHandlerSelectors.basePackage("com.husky.controller"))
                .paths(PathSelectors.any())
                .build()
            	// 配置swagger带上token
                .globalRequestParameters(Collections.singletonList(
                        new RequestParameterBuilder()
                            .name("Access-Token")
                            .description("Access-Token")
                            .in(ParameterType.HEADER)
                            .required(false)
                            .query(q -> q.model(m -> m.scalarModel(ScalarType.STRING)))
                            .build()));;
        return docket;
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("在线考试系统")
                .version("1.0")
                .description("在线考试系统接口文档")
                .contact(new Contact("husky","https://github.com/Husky-Jie/online-exam","1583893320@qq.com"))
                .build();
    }
}
```



### 8.3.3 Swagger使用

访问地址为：localhost:8080/doc.html

示例：

```java
@Api(tags = "地址簿相关接口")
@ApiModel("地址簿")
@ApiModelProperty("主键")
@ApiOperation(value = "显示所有地址列表")
@ApiImplicitParams({
    @ApiImplicitParam(name = "addressBook",value = "地址簿信息",dataType = "AddressBook")
})
// 注意：@ApiImplicitParam()中的参数若不写会报空指针异常
```

# 8.4项目部署

![image-20221106164432621](.\img\image-20221106164432621.png)



# 9.返回结果类

```java
package com.husky.common;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/1/28
 * Time: 16:24
 */
public class ApiResult<T> implements Serializable {

    private Integer code; //编码：1成功，0和其它数字为失败

    private String msg; //错误信息

    private T data; //数据

    private Map map = new HashMap(); //动态数据

    public static <T> ApiResult<T> success(T object) {
        ApiResult<T> r = new ApiResult<T>();
        r.data = object;
        r.code = 1;
        return r;
    }

    public static <T> ApiResult<T> error(String msg) {
        ApiResult r = new ApiResult();
        r.msg = msg;
        r.code = 0;
        return r;
    }
}

```



# 10.使用spring解决跨域问题

定义跨域过滤器

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

/**
 * @description 跨域过虑器
 * @author Mr.M
 * @date 2022/9/7 11:04
 * @version 1.0
 */
 @Configuration
 public class GlobalCorsConfig {

  /**
   * 允许跨域调用的过滤器
   */
  @Bean
  public CorsFilter corsFilter() {
   CorsConfiguration config = new CorsConfiguration();
   //允许白名单域名进行跨域调用
   config.addAllowedOrigin("*");
   //允许跨越发送cookie
   config.setAllowCredentials(true);
   //放行全部原始头信息
   config.addAllowedHeader("*");
   //允许所有请求方法跨域调用
   config.addAllowedMethod("*");
   UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
   source.registerCorsConfiguration("/**", config);
   return new CorsFilter(source);
  }
 }

```



# 11.使用sql进行递归查询(树表查询)

```sql
with RECURSIVE t1  AS
(
  SELECT 1 as n
  UNION ALL
  SELECT n + 1 FROM t1 WHERE n < 5
)
SELECT * FROM t1;

```

说明：

t1 相当于一个表名

select 1 相当于这个表的初始值，这里使用UNION ALL 不断将每次递归得到的数据加入到表中。

n<5为递归执行的条件，当n>=5时结束递归调用。



## 例子2

```sql
with recursive t1 as (
select * from  course_category p where  id= '1'
union all
 select t.* from course_category t inner join t1 on t1.id = t.parentid
)
select *  from t1 order by t1.id, t1.orderby
```

查询结果如下：

![img](.\assets\clip_image002.gif)

t1表中初始的数据是id等于1的记录，即根结点。

通过inner join t1 t2 on t2.id = t.parentid 找到id='1'的下级节点 。

通过这种方法就找到了id='1'的所有下级节点，下级节点包括了所有层级的节点。

上边这种方法是向下递归，即找到初始节点的所有下级节点。



# 12.stream流封装树形表课程分类

```java
@Override
public List<CourseCategoryTreeDto> queryTreeNodes(String id) {
    List<CourseCategoryTreeDto> courseCategoryTreeDtos = courseCategoryMapper.selectTreeNodes(id);
    // 将list转map,以备使用,排除根节点
    Map<String, CourseCategoryTreeDto> map = courseCategoryTreeDtos
            .stream()
            .filter(item->!id.equals(item.getId()))
            .collect(Collectors.toMap(key -> key.getId(), value -> value, (key1, key2) -> key2));

    // 定义一个list，作为最终结果
    List<CourseCategoryTreeDto> categoryList = new ArrayList<>();

    //依次遍历每个元素,排除根节点
    courseCategoryTreeDtos
            .stream()
            .filter(item->!id.equals(item.getId()))
            .forEach(item->{
                if (item.getParentid().equals(id)){
                    // 找到所有的父节点，排除根节点
                    categoryList.add(item);
                }
                // 找到该节点的父节点
                CourseCategoryTreeDto courseCategoryParent = map.get(item.getParentid());
                if (courseCategoryParent != null) {
                    // 如果父节点中的ChildrenTreeNodes属性为空，则new一个集合，向该集合中存放该节点的子节点
                    if (courseCategoryParent.getChildrenTreeNodes() == null) {
                        courseCategoryParent.setChildrenTreeNodes(new ArrayList<CourseCategoryTreeDto>());
                    }
                    // 存放父节点的字节点
                    courseCategoryParent.getChildrenTreeNodes().add(item);
                }
            });
    return categoryList;
}
```



# 异常统一处理

## 通用异常信息

```java
package com.husky.base.exception;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/9
 * Time: 20:40
 * Description: 通用异常信息
 */
public enum CommonError {
    UNKOWN_ERROR("执行过程异常，请重试。"),
    PARAMS_ERROR("非法参数"),
    OBJECT_NULL("对象为空"),
    QUERY_NULL("查询结果为空"),
    REQUEST_NULL("请求参数为空");

    private String errMessage;

    public String getErrMessage() {
        return errMessage;
    }

    CommonError(String errMessage) {
        this.errMessage = errMessage;
    }
}

```



## 自定义异常类型

```java
package com.husky.base.exception;

import lombok.Data;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/9
 * Time: 20:36
 * Description: 自定义异常类型
 */
@Data
public class XueChengException extends RuntimeException{

    private String errMessage;

    public XueChengException() {
        super();
    }

    public XueChengException(String errMessage) {
        super(errMessage);
        this.errMessage = errMessage;
    }


    public static void cast(CommonError commonError){
        throw new XueChengException(commonError.getErrMessage());
    }

    public static void cast(String errMessage){
        throw new XueChengException(errMessage);
    }

}
```



## 响应用户的统一异常类型

```java
package com.husky.base.exception;

import lombok.Data;

import java.io.Serializable;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/9
 * Time: 20:41
 * Description: 响应用户的统一异常类型
 */

public class RestErrorResponse implements Serializable {

    private String errMessage;

    public RestErrorResponse(String errMessage){
        this.errMessage= errMessage;
    }

    public String getErrMessage() {
        return errMessage;
    }

    public void setErrMessage(String errMessage) {
        this.errMessage = errMessage;
    }

}
```



## 全局异常处理器

 从 Spring 3.0 - Spring 3.2 版本之间，对 Spring 架构和 SpringMVC 的Controller 的异常捕获提供了相应的异常处理。

- @ExceptionHandler

  Spring3.0提供的标识在方法上或类上的注解，用来表明方法的处理异常类型。

  

- @ControllerAdvice

  Spring3.2提供的新注解，从名字上可以看出大体意思是控制器增强，    在项目中来增强SpringMVC中的Controller。

  通常和**@ExceptionHandler** 结合使用，来处理SpringMVC的异常信息。

  

- @ResponseStatus

  Spring3.0提供的标识在方法上或类上的注解，用状态代码和应返回的原因标记方法或异常类。
   调用处理程序方法时，状态代码将应用于HTTP响应。

```java
package com.husky.base.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/9
 * Time: 20:50
 * Description: 全局异常处理器
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(XueChengException.class)
    @ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse customException(XueChengException e){
        log.error("系统异常{}", e.getErrMessage());

        // 解析异常信息
        String errMessage = e.getErrMessage();
        RestErrorResponse restErrorResponse = new RestErrorResponse(errMessage);
        return restErrorResponse;
    }

    @ExceptionHandler(Exception.class)
    @ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse customException(Exception e){
        log.error("系统异常{}", e.getMessage(), e);

        // 解析异常信息
        RestErrorResponse restErrorResponse = new RestErrorResponse(CommonError.UNKOWN_ERROR.getErrMessage());
        return restErrorResponse;
    }
}
```



# **JSR303校验**



早在JavaEE6规范中就定义了参数校验的规范，它就是JSR-303，它定义了Bean Validation，即对bean属性进行校验。

SpringBoot提供了JSR-303的支持，它就是spring-boot-starter-validation，它的底层使用Hibernate Validator，Hibernate Validator是Bean Validation 的参考实现。

所以，我们准备在Controller层使用spring-boot-starter-validation完成对请求参数的基本合法性进行校验。

## 引入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```



## 常用注解

**在dto，vo等模型中使用**

![image-20230409224419096](.\assets\image-20230409224419096.png)

例子

```java
@Data
@ApiModel(value="AddCourseDto", description="新增课程基本信息")
public class AddCourseDto {

 @NotEmpty(message = "课程名称不能为空")
 @ApiModelProperty(value = "课程名称", required = true)
 private String name;

 @NotEmpty(message = "适用人群不能为空")
 @Size(message = "适用人群内容过少",min = 10)
 @ApiModelProperty(value = "适用人群", required = true)
 private String users;

 @ApiModelProperty(value = "课程标签")
 private String tags;

 @NotEmpty(message = "课程分类不能为空")
 @ApiModelProperty(value = "大分类", required = true)
 private String mt;
}
```

## 开启校验功能

对接口参数进行校验，需要使用@Validated注解开启校验功能

例子

```java
/**
 *
 * @param addCourseDto   @Validated：启动JSR303校验
 * @return
 */
@ApiOperation(value = "新增课程信息接口")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(@RequestBody @Validated AddCourseDto addCourseDto) {
    return courseBaseService.addCourseBase(1232141425L, addCourseDto);
}
```



## 校验出错异常统一处理

如果校验出错Spring会抛出MethodArgumentNotValidException异常，我们需要在统一异常处理器中捕获异常，解析出异常信息。

代码如下

```java
@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR)
public RestErrorResponse customException(MethodArgumentNotValidException e){
    // 解析异常信息
    BindingResult bindingResult = e.getBindingResult();
    List<String> errors = new ArrayList<>();
    bindingResult.getFieldErrors().stream().forEach(item->{
        errors.add(item.getDefaultMessage());
    });
    // 拼接list集合
    String errMessage = StringUtils.join(errors, "，");
    log.error("系统异常{}", errMessage, e);


    RestErrorResponse restErrorResponse = new RestErrorResponse(errMessage);
    return restErrorResponse;
}
```



## 分组校验

有时候在同一个属性上设置一个校验规则不能满足要求，比如：订单编号由系统生成，在添加订单时要求订单编号为空，在更新 订单时要求订单编写不能为空。此时就用到了分组校验，同一个属性定义多个校验规则属于不同的分组，比如：添加订单定义@NULL规则属于insert分组，更新订单定义@NotEmpty规则属于update分组，insert和update是分组的名称，是可以修改的。



用class类型来表示不同的分组，所以我们定义不同的接口类型（空接口）表示不同的分组，由于校验分组是公用的，所以定义在 base工程中。如下：

```java
package com.husky.base.exception;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/9
 * Time: 22:54
 * Description: 校验分组
 */
public class ValidationGroups {
    public interface Insert{};
    public interface Update{};
    public interface Delete{};
}
```



在定义校验规则时指定分组：

```java
@NotEmpty(message = "课程id不能为空", groups = ValidationGroups.Update.class)
@ApiModelProperty(value = "课程id", required = true)
private Long id;

@NotEmpty(message = "新增课程名称不能为空", groups = ValidationGroups.Insert.class)
@ApiModelProperty(value = "课程名称", required = true)
private String name;
```



在Controller方法中启动校验规则指定要使用的分组名：

```java
/**
 *
 * @param addCourseDto   @Validated：启动JSR303校验
 * @return
 */
@ApiOperation(value = "新增课程信息接口")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(
        @RequestBody
        @Validated(value = ValidationGroups.Insert.class)
        AddCourseDto addCourseDto) {
    return courseBaseService.addCourseBase(1232141425L, addCourseDto);
}
```



## **校验规则不满足？**

如果javax.validation.constraints包下的校验规则满足不了需求怎么办？

1、手写校验代码 。

比如，在学成项目中，新增课程的费用是免费时，价格参数是可以为空的，若为付费，则价格不能为空且需要大于0，所以接口接收的参数，JSR303校验框架是不能分辨该课程是否为收费的，这样我们就需要手动校验。

```java
/收费规则为收费
if(charge.equals("201001")){
    if(courseMarketNew.getPrice() == null || courseMarketNew.getPrice()<=0){
        throw new XueChengException("课程为收费价格不能为空且必须大于0");
    }else if (courseMarketNew.getOriginalPrice() == null || courseMarketNew.getOriginalPrice() <= 0) {
        throw new XueChengException("课程为收费价格不能为空且必须大于0");
    }
}
```

2、自定义校验规则注解。



# nacos

## 服务注册

引入依赖，才能使用服务注册相关配置

```xml
 <!-- nacos注册中心 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```



## 配置中心

引入依赖，才能使用配置中心相关配置

```xml
<!-- nacos配置中心 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```



## 配置文件

```yaml
#微服务配置
spring:
  application:
    name: system-api
  # nacos注册中心
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery: # 服务注册相关配置
        namespace: 2e762a60-9338-49c2-bc8c-97a56be92b48
        group: xuecheng-plus-project
      config:   # 配置文件相关配置
        namespace: 2e762a60-9338-49c2-bc8c-97a56be92b48
        group: xuecheng-plus-project
        file-extension: yaml
        refresh-enabled: true
        extension-configs:  # 扩展配置
          - data-id: system-service-${spring.profiles.active}.yaml
            group: xuecheng-plus-project
            refresh: true
         shared-configs:	# 共享配置
          - data-id: logging-${spring.profiles.active}.yaml
            group: xuecheng-plus-common
            refresh: true
  # 指定环境
  profiles:
    active: dev
  # swagger 版本冲突配置
  mvc:
    pathmatch:
      matching-strategy: ant_path_matcher
# 日志文件配置路径
logging:
  config: classpath:log4j2-dev.xml


```



## Data-ID的命名规则

dataid有三部分组成

比如：content-service-dev.yaml配置文件 由（content-service）-（dev）. (yaml)三部分组成

- content-service：第一部分，它是在application.yaml中配置的应用名，即spring.application.name的值。
- dev：第二部分，它是环境名，通过**spring.profiles.active**指定，
- Yaml: 第三部分，它是配置文件 的后缀，目前nacos支持properties、yaml等格式类型



# springSecurity

## 引入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
```



## 工作原理

![image-20230422214309262](.\assets\image-20230422214309262.png)

主要的几个过滤器及其作用：

**SecurityContextPersistenceFilter** 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext；

**UsernamePasswordAuthenticationFilter** 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；

**FilterSecurityInterceptor** 是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问，前面已经详细介绍过了；

**ExceptionTranslationFilter** 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。



## 执行流程

1. 用户提交用户名、密码被SecurityFilterChain中的UsernamePasswordAuthenticationFilter过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。
2. 然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证
3. 认证成功后，AuthenticationManager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication实例。
4. SecurityContextHolder安全上下文容器将第3步填充了信息的Authentication，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。
5. 可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个List<AuthenticationProvider>列表，存放多种认证方式，最终实际的认证工作是由AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。

## 配置

```java
package com.husky.auth.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

/**
 * @author Mr.M
 * @version 1.0
 * @description 安全管理配置
 * @date 2022/9/26 20:53
 */
@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


    //配置用户信息服务
    @Bean
    public UserDetailsService userDetailsService() {
        //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
        manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
        return manager;
    }

    // 密码比对，返回UserDetails子实现对象后，框架自动进行密码比对，调用matches(参数1，参数2)方法
    // 参数1为原密码， 参数2为加密过后的密码
    @Bean
    public PasswordEncoder passwordEncoder() {
		//密码为明文方式
        // return NoOpPasswordEncoder.getInstance();
		return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }


    //配置安全拦截机制
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                .antMatchers("/r/**").authenticated()//访问/r开始的请求需要认证通过
                .anyRequest().permitAll()//其它请求全部放行
                .and()
                .formLogin().successForwardUrl("/login-success");//登录成功跳转到/login-success
    }



}
```



## 用户认证

实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可，架调用loadUserByUsername()方法拿到用户信息之后是如何执行的，见下图：

<img src=".\assets\image-20230425221620857.png" alt="image-20230425221620857" style="zoom:50%;" />



### 实现UserDetailsService

重写loadUserByUsername()方法

```java
package com.husky.ucenter.service.impl;

import com.alibaba.fastjson.JSON;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.husky.ucenter.mapper.XcUserMapper;
import com.husky.ucenter.model.po.XcUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/25
 * Time: 20:55
 * Description: TODO
 */
@Component
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    private XcUserMapper xcUserMapper;

    /**
     * 根据账号查询用户信息
     * @param username 用户账号
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        LambdaQueryWrapper<XcUser> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(XcUser::getUsername, username);
        // 根据username查询用户
        XcUser xcUser = xcUserMapper.selectOne(queryWrapper);

        // 查询用户不存在，返回空即可， spring Security框架抛出异常用户不存在
        if (xcUser == null) {
            return null;
        }

        // 拿到用户正确密码
        String password = xcUser.getPassword();
        // 屏蔽敏感数据，密码
        xcUser.setPassword(null);

        // 用户权限, 不设置会报错
        String[] authorities = {"test"};

        // 将用户信息转为json
        String json = JSON.toJSONString(xcUser);
        // 若不为空，拿到正确的密码，最终封装成UserDetails对象给springSecurity框架返回，由框架进行密码比对
        // 将用户信息存入令牌中，解析令牌，可知用户信息存入在user_name中，并保存在上下文中
        UserDetails userDetails = User.withUsername(json).password(password).authorities(authorities).build();

        return userDetails;
    }
}
```



# 统一认证入口



## 封装统一认证参数

```java
package com.husky.ucenter.model.dto;

import lombok.Data;

import java.util.HashMap;
import java.util.Map;

/**
 * @author Mr.M
 * @version 1.0
 * @description 认证用户请求参数
 * @date 2022/9/29 10:56
 */
@Data
public class AuthParamsDto {

    private String username; //用户名
    private String password; //域  用于扩展
    private String cellphone;//手机号
    private String checkcode;//验证码
    private String checkcodekey;//验证码key
    private String authType; // 认证的类型   password:用户名密码模式类型    sms:短信模式类型
    //附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId
    private Map<String, Object> payload = new HashMap<>();


}
```



## 重写密码比对

原来的DaoAuthenticationProvider 会进行密码校验，现在重新定义DaoAuthenticationProviderCustom类，重写类的additionalAuthenticationChecks方法。

```java
package com.husky.auth.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/29
 * Time: 20:44
 * Description: 自定义DaoAuthenticationProvider，重写密码比对方法，
 */
@Component
public class DaoAuthenticationProviderCustom extends DaoAuthenticationProvider {

    /**
     * 设置userDetailsService子实现类UserServiceImpl对象
     * @param userDetailsService @Qualifier用来区分存在多个bean
     */
    @Autowired
    @Override
    public void setUserDetailsService(@Qualifier("UserServiceImpl") UserDetailsService userDetailsService) {
        super.setUserDetailsService(userDetailsService);
    }


    @Override
    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {

    }
}
```



在WebSecurityConfig类指定daoAuthenticationProviderCustom

```java
@Autowired
DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;


/**
 * 使springSecurity知道修改了DaoAuthenticationProvider的密码比对方法
 * @param auth
 * @throws Exception
 */
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.authenticationProvider(daoAuthenticationProviderCustom);
}
```



## 定义认证的接口并实现

### 认证接口

不同的认证方式使用不同的子实现类对象

```java
package com.husky.ucenter.service;

import com.husky.ucenter.model.dto.AuthParamsDto;
import com.husky.ucenter.model.dto.XcUserExt;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/29
 * Time: 21:10
 * Description: 统一认证的接口
 */
public interface AuthService {

    /**
     * @description 认证方法
     * @param authParamsDto 认证参数
     * @return com.xuecheng.ucenter.model.po.XcUser 用户信息
     * @author Mr.M
     * @date 2022/9/29 12:11
     */
    XcUserExt execute(AuthParamsDto authParamsDto);

}
```



### 解决多个bean无法连接的报错

多个类实现AuthService接口，在@Service注解上添加名称，之后

- 在自动注入对象上添加@Qualifier("")注解

- 注入spring容器，手动选择

  - ```java
    @Autowired
    private ApplicationContext applicationContext;
    
    AuthService authService = applicationContext.getBean(beanName, AuthService.class);
    ```



## 修改UserServiceImpl

现在传入的验证信息是统一的认证参数authParamsDto的json对象



```java
package com.husky.ucenter.service.impl;

import com.alibaba.fastjson.JSON;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.husky.base.exception.XueChengException;
import com.husky.ucenter.mapper.XcUserMapper;
import com.husky.ucenter.model.dto.AuthParamsDto;
import com.husky.ucenter.model.dto.XcUserExt;
import com.husky.ucenter.model.po.XcUser;
import com.husky.ucenter.service.AuthService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

/**
 * Created by IntelliJ IDEA.
 * User: 周圣杰
 * Date: 2023/4/25
 * Time: 20:55
 * Description: TODO
 */
@Component("UserServiceImpl")
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    private XcUserMapper xcUserMapper;

    @Autowired
    private ApplicationContext applicationContext;

    /**
     * 根据账号查询用户信息
     * @param authParams  传入的请求认证参数就是AuthParamsDto
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String authParams) throws UsernameNotFoundException {

        AuthParamsDto authParamsDto = null;
        try {
            // 将传入的json转为AuthParamsDto对象
            authParamsDto = JSON.parseObject(authParams, AuthParamsDto.class);
        } catch (Exception e) {
            throw new XueChengException("请求认证不符合要求");
        }

        // 登录类型
        String authType = authParamsDto.getAuthType();

        // 根据不同的登录类型从spring容器中选取指定的bean
        String beanName = authType + "_authService";
        AuthService authService = applicationContext.getBean(beanName, AuthService.class);

        // 调用统一的execute方法完成认证
        XcUserExt xcUserExt = authService.execute(authParamsDto);

 		// 。。。
        。。。。
            。。。。
}

```







# OAuth2

OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。



## 微信登录认证流程图

![image-20230422214812384](.\assets\image-20230422214812384.png)



微信扫码的目的是通过微信认证登录黑马程序员官网，黑马程序员网站需要从微信获取当前用户的身份信息才会让当前用户在黑马网站登录成功。

现在搞清楚几个概念：

资源：用户信息，在微信中存储。

资源拥有者：用户是用户信息资源的拥有者。

认证服务：微信负责认证当前用户的身份，负责为客户端颁发令牌。

客户端：客户端会携带令牌请求微信获取用户信息，黑马程序员网站即客户端，黑马网站需要在浏览器打开。



询问用户是否授权黑马程序员访问自己在微信的用户信息，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码给黑马程序员的网站。

1. 只有资源拥有者同意微信才允许黑马网站访问资源。
2. 黑马程序员的网站获取到授权码
3. 携带授权码请求微信认证服务器申请令牌
4. 微信认证服务器向黑马程序员的网站响应令牌
5. 黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。
6. 资源服务器返回受保护资源即用户信息
7. 黑马网站接收到用户信息，此时用户在黑马网站登录成功。



## 认证流程

![image-20230422215223868](.\assets\image-20230422215223868.png)

Oauth2包括以下角色：

1、客户端

本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：手机客户端、浏览器等。

上边示例中黑马网站即为客户端，它需要通过浏览器打开。

2、资源拥有者

通常为用户，也可以是应用程序，即该资源的拥有者。

A表示 客户端请求资源拥有者授权。

B表示 资源拥有者授权客户端即黑马网站访问自己的用户信息。

3、授权服务器（也称认证服务器）

认证服务器对资源拥有者进行认证，还会对客户端进行认证并颁发令牌。

C 客户端即黑马网站携带授权码请求认证。

D认证通过颁发令牌。

4、资源服务器

存储资源的服务器。

E表示客户端即黑马网站携带令牌请求资源服务器获取资源。

F表示资源服务器校验令牌通过后提供受保护资源。

## 配置类

### 授权服务配置

```java
package com.husky.auth.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;

import javax.annotation.Resource;

/**
 * @description 授权服务器配置
 * @author Mr.M
 * @date 2022/9/26 22:25
 * @version 1.0
 */
 @Configuration
 @EnableAuthorizationServer
 public class AuthorizationServer extends AuthorizationServerConfigurerAdapter {

  @Resource(name="authorizationServerTokenServicesCustom")
  private AuthorizationServerTokenServices authorizationServerTokenServices;

 @Autowired
 private AuthenticationManager authenticationManager;

  //客户端详情服务
  @Override
  public void configure(ClientDetailsServiceConfigurer clients)
          throws Exception {
        clients.inMemory()// 使用in-memory存储
                .withClient("XcWebApp")// client_id
                .secret("XcWebApp")//客户端密钥
//                .secret(new BCryptPasswordEncoder().encode("XcWebApp"))//客户端密钥
                .resourceIds("xuecheng-plus")//资源列表
                .authorizedGrantTypes("authorization_code", "password","client_credentials","implicit","refresh_token")// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials
                .scopes("all")// 允许的授权范围
                .autoApprove(false)//false跳转到授权页面
                //客户端接收授权码的重定向地址
                .redirectUris("http://www.51xuecheng.cn")
   ;
  }


  //令牌端点的访问配置
  @Override
  public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
   endpoints
           .authenticationManager(authenticationManager)//认证管理器
           .tokenServices(authorizationServerTokenServices)//令牌管理服务
           .allowedTokenEndpointRequestMethods(HttpMethod.POST);
  }

  //令牌端点的安全配置
  @Override
  public void configure(AuthorizationServerSecurityConfigurer security){
   security
           .tokenKeyAccess("permitAll()")                    //oauth/token_key是公开
           .checkTokenAccess("permitAll()")                  //oauth/check_token公开
           .allowFormAuthenticationForClients();			//表单认证（申请令牌）
  }
 }

```

## OAuth2的授权模式

Spring Security支持OAuth2认证，OAuth2提供授权码模式、密码模式、简化模式、客户端模式等四种授权模式，前边举的微信扫码登录的例子就是基于授权码模式，这四种模式中授权码模式和密码模式应用较多。

### 授权码模式

授权码模式简单理解是使用授权码去获取令牌，要想获取令牌先要获取授权码，授权码的获取需要资源拥有者亲自授权同意才可以获取。

#### 授权流程

<img src=".\assets\image-20230422220709019.png" alt="image-20230422220709019" style="zoom:50%;" />

以黑马网站微信扫码登录为例进行说明：

1、用户打开浏览器。

2、通过浏览器访问客户端即黑马网站。

3、用户通过浏览器向认证服务请求授权，请求授权时会携带客户端的URL，此URL为下发授权码的重定向地址。

4、认证服务向资源拥有者返回授权页面。

5、资源拥有者亲自授权同意。

6、通过浏览器向认证服务发送授权同意。

7、认证服务向客户端地址重定向并携带授权码。

8、客户端即黑马网站收到授权码。

9、客户端携带授权码向认证服务申请令牌。

10、认证服务向客户端颁发令牌。





#### 获取授权码参数说明

举例地址: http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&response_type=code&scope=all&redirect_uri=http://www.51xuecheng.cn

参数列表如下：

•     client_id：客户端准入标识。

•     response_type：授权码模式固定为code。

•     scope：客户端权限。

•     redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）。



#### 使用授权码申请令牌参数说明

举例地址：http://localhost:63070/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=authorization_code&code=授权码&redirect_uri=http://www.51xuecheng.cn/

参数列表如下

•     client_id：客户端准入标识。

•     client_secret：客户端秘钥。

•     grant_type：授权类型，填写authorization_code，表示授权码模式

•     code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。

•     redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。



### 密码模式

密码模式相对授权码模式简单，授权码模式需要借助浏览器供用户亲自授权，密码模式不用借助浏览器，如下图：

#### 流程

<img src=".\assets\image-20230422221835122.png" alt="image-20230422221835122" style="zoom:50%;" />

1、资源拥有者提供账号和密码

2、客户端向认证服务申请令牌，请求中携带账号和密码

3、认证服务校验账号和密码正确颁发令牌。



#### 获取令牌地址参数说明

/oauth/token?client_id=XcWebApp&client_secret=XcWebApp&grant_type=password&username=shangsan&password=123

参数列表如下：

1.  client_id：客户端准入标识。
2.  client_secret：客户端秘钥。
3.  grant_type：授权类型，填写password表示密码模式
4.  username：资源拥有者用户名。
5.  password：资源拥有者密码。

获取结果：

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2ODIzNTI2NzgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImVmMjU1ZDNhLTVhZjUtNDQ5OC1iMjA4LTFmNGI2NGU3ODI5MiIsImNsaWVudF9pZCI6IlhjV2ViQXBwIn0.DBvrLCJAIsc9_ssZb4l5JzQgqN_2HvimkrhOzgUJ44A",
  "token_type": "bearer",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJlZjI1NWQzYS01YWY1LTQ0OTgtYjIwOC0xZjRiNjRlNzgyOTIiLCJleHAiOjE2ODI2MDQ2NzgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6IjRjOTY0MWE3LWQ2NzItNDQ5Yi05NGFlLWJmZTY2NWI0ZjdhYSIsImNsaWVudF9pZCI6IlhjV2ViQXBwIn0.chI3JkYVboNicye84iijMDeKAm-jKaVpmRAtAP_CX0Y",
  "expires_in": 7199,
  "scope": "all",
  "jti": "ef255d3a-5af5-4498-b208-1f4b64e78292"
}
```







# JWT

## 生成jwt令牌的配置

```java
package com.husky.auth.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

import java.util.Arrays;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class TokenConfig {

    private String SIGNING_KEY = "mq123";

    @Autowired
    TokenStore tokenStore;

//    @Bean
//    public TokenStore tokenStore() {
//        //使用内存存储令牌（普通令牌）
//        return new InMemoryTokenStore();
//    }

    @Autowired
    private JwtAccessTokenConverter accessTokenConverter;

    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }

    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey(SIGNING_KEY);
        return converter;
    }

    //令牌管理服务
    @Bean(name="authorizationServerTokenServicesCustom")
    public AuthorizationServerTokenServices tokenService() {
        DefaultTokenServices service=new DefaultTokenServices();
        service.setSupportRefreshToken(true);//支持刷新令牌
        service.setTokenStore(tokenStore);//令牌存储策略

        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));
        service.setTokenEnhancer(tokenEnhancerChain);

        service.setAccessTokenValiditySeconds(7200); // 令牌默认有效期2小时
        service.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天
        return service;
    }
}
```



## 校验jwt令牌

生成令牌的示例（参考OAuth的密码模式）

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2ODIzNTI2NzgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImVmMjU1ZDNhLTVhZjUtNDQ5OC1iMjA4LTFmNGI2NGU3ODI5MiIsImNsaWVudF9pZCI6IlhjV2ViQXBwIn0.DBvrLCJAIsc9_ssZb4l5JzQgqN_2HvimkrhOzgUJ44A",
  "token_type": "bearer",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsieHVlY2hlbmctcGx1cyJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJlZjI1NWQzYS01YWY1LTQ0OTgtYjIwOC0xZjRiNjRlNzgyOTIiLCJleHAiOjE2ODI2MDQ2NzgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6IjRjOTY0MWE3LWQ2NzItNDQ5Yi05NGFlLWJmZTY2NWI0ZjdhYSIsImNsaWVudF9pZCI6IlhjV2ViQXBwIn0.chI3JkYVboNicye84iijMDeKAm-jKaVpmRAtAP_CX0Y",
  "expires_in": 7199,
  "scope": "all",
  "jti": "ef255d3a-5af5-4498-b208-1f4b64e78292"
}
```



```http
### 校验jwt令牌
POST http://localhost:63071/auth/oauth/check_token?token=access_token的值
```



## 资源服务校验令牌

每个资源服务的api都需要携带令牌，认证成功才能访问

```http
### 携带token访问资源服务
GET http://localhost:63040/content/course/2
Authorization: Bearer  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzM0OTgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6IjhhM2M2OTk1LWU1ZGEtNDQ1Yy05ZDAyLTEwNDFlYzk3NTkwOSIsImNsaWVudF9pZCI6ImMxIn0.73eNDxTX5ifttGCjwc7xrd-Sbp_mCfcIerI3lGetZto
```



### 资源服务（内容管理服务，媒资管理等）添加依赖

```xml
<!--认证相关-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
```



### 资源服务的api模块中添加配置文件

```java
package com.husky.content.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.TokenStore;

/**
 * @description 资源服务配置
 * @author Mr.M
 * @date 2022/10/18 16:33
 * @version 1.0
 */
 @Configuration
 @EnableResourceServer
 @EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
 public class ResourceServerConfig extends ResourceServerConfigurerAdapter {


  //资源服务标识   要和认证服务模块中的授权服务配置的.resourceIds("xuecheng-plus")相同
  public static final String RESOURCE_ID = "xuecheng-plus";

  @Autowired
  TokenStore tokenStore;

  @Override
  public void configure(ResourceServerSecurityConfigurer resources) {
   resources.resourceId(RESOURCE_ID)//资源 id
           .tokenStore(tokenStore)
           .stateless(true);
  }

 @Override
 public void configure(HttpSecurity http) throws Exception {
  http.csrf().disable()
          .authorizeRequests()
                .antMatchers("/r/**","/course/**").authenticated()// 所有/r和/**的请求必须认证通过
          .anyRequest().permitAll()
  ;
 }

 }
```



```java
package com.husky.content.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

import java.util.Arrays;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class TokenConfig {

    String SIGNING_KEY = "mq123";


//    @Bean
//    public TokenStore tokenStore() {
//        //使用内存存储令牌（普通令牌）
//        return new InMemoryTokenStore();
//    }

    @Autowired
    private JwtAccessTokenConverter accessTokenConverter;

    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(accessTokenConverter());
    }

    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey(SIGNING_KEY);
        return converter;
    }
}
```



# 网关认证

gateway网关的三个作用：只做认证不做授权

1. 校验jwt的合法性
   - 除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。
2. 路由url
3. 网站白名单维护：针对不用认证的URL全部放行



## 添加依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>

```



## 配置文件（白色名单）

```properties
/**=临时全部放行
/auth/**=认证地址
/content/open/**=内容管理公开访问接口
/media/open/**=媒资管理公开访问接口
```



## 网关认证过滤器

```java
package com.husky.gateway.config;

import com.alibaba.fastjson.JSON;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Set;

/**
 * @author Mr.M
 * @version 1.0
 * @description 网关认证过虑器
 * @date 2022/9/27 12:10
 */
@Component
@Slf4j
public class GatewayAuthFilter implements GlobalFilter, Ordered {


    //白名单
    private static List<String> whitelist = null;

    static {
        //加载白名单
        try (
                InputStream resourceAsStream = GatewayAuthFilter.class.getResourceAsStream("/security-whitelist.properties");
        ) {
            Properties properties = new Properties();
            properties.load(resourceAsStream);
            Set<String> strings = properties.stringPropertyNames();
            whitelist= new ArrayList<>(strings);

        } catch (Exception e) {
//            log.error("加载/security-whitelist.properties出错:{}",e.getMessage());
            e.printStackTrace();
        }


    }

    @Autowired
    private TokenStore tokenStore;


    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String requestUrl = exchange.getRequest().getPath().value();
        AntPathMatcher pathMatcher = new AntPathMatcher();
        //白名单放行
        for (String url : whitelist) {
            if (pathMatcher.match(url, requestUrl)) {
                return chain.filter(exchange);
            }
        }

        //检查token是否存在
        String token = getToken(exchange);
        if (StringUtils.isBlank(token)) {
            return buildReturnMono("没有认证",exchange);
        }
        //判断是否是有效的token
        OAuth2AccessToken oAuth2AccessToken;
        try {
            oAuth2AccessToken = tokenStore.readAccessToken(token);

            boolean expired = oAuth2AccessToken.isExpired();
            if (expired) {
                return buildReturnMono("认证令牌已过期",exchange);
            }
            return chain.filter(exchange);
        } catch (InvalidTokenException e) {
            log.info("认证令牌无效: {}", token);
            return buildReturnMono("认证令牌无效",exchange);
        }

    }

    /**
     * 获取token
     */
    private String getToken(ServerWebExchange exchange) {
        String tokenStr = exchange.getRequest().getHeaders().getFirst("Authorization");
        if (StringUtils.isBlank(tokenStr)) {
            return null;
        }
        String token = tokenStr.split(" ")[1];
        if (StringUtils.isBlank(token)) {
            return null;
        }
        return token;
    }




    private Mono<Void> buildReturnMono(String error, ServerWebExchange exchange) {
        ServerHttpResponse response = exchange.getResponse();
        String jsonString = JSON.toJSONString(new RestErrorResponse(error));
        byte[] bits = jsonString.getBytes(StandardCharsets.UTF_8);
        DataBuffer buffer = response.bufferFactory().wrap(bits);
        response.setStatusCode(HttpStatus.UNAUTHORIZED);
        response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");
        return response.writeWith(Mono.just(buffer));
    }


    @Override
    public int getOrder() {
        return 0;
    }
}
```

